{
  "meta": {
    "title": "Building a Distributed Rate Limiter",
    "slug": "distributed-rate-limiter",
    "date": "2026-02-19",
    "tags": [
      "system-design",
      "distributed-systems"
    ],
    "summary": "Rate limiting is a reliability feature, not a billing feature. Done well, it prevents cascading failure and keeps latency predictable under load.",
    "readingTime": 1,
    "published": true
  },
  "html": "<p>Rate limiting is a reliability feature, not a billing feature. Done well, it prevents cascading failure and keeps latency predictable under load.</p>\n<h2 id=\"the-problem\"><a class=\"blog-heading-anchor\" href=\"#the-problem\">The problem</a></h2>\n<p>You need a global budget (e.g. 2,000 req/s) enforced across many instances and regions, with burst tolerance and low coordination overhead.</p>\n<h2 id=\"a-practical-model\"><a class=\"blog-heading-anchor\" href=\"#a-practical-model\">A practical model</a></h2>\n<p>Start with a token bucket per key. Tokens refill at a steady rate. Each request consumes 1 token.</p>\n<div class=\"blog-codeblock\" data-lang=\"ts\"><button type=\"button\" class=\"blog-codeblock__copy\" data-blog-copy=\"code\" aria-label=\"Copy code to clipboard\">Copy</button><div class=\"blog-codeblock__inner\"><pre class=\"shiki github-light\" style=\"background-color:#fff;color:#24292e\" tabindex=\"0\" class=\"blog-code-pre blog-code-pre--light\"><code><span class=\"line\"><span style=\"color:#D73A49\">type</span><span style=\"color:#6F42C1\"> Bucket</span><span style=\"color:#D73A49\"> =</span><span style=\"color:#24292E\"> { </span><span style=\"color:#E36209\">tokens</span><span style=\"color:#D73A49\">:</span><span style=\"color:#005CC5\"> number</span><span style=\"color:#24292E\">; </span><span style=\"color:#E36209\">lastRefillMs</span><span style=\"color:#D73A49\">:</span><span style=\"color:#005CC5\"> number</span><span style=\"color:#24292E\"> }</span></span></code></pre><pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" class=\"blog-code-pre blog-code-pre--dark\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Bucket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">tokens</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> number</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">lastRefillMs</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> number</span><span style=\"color:#E1E4E8\"> }</span></span></code></pre></div></div>\n<h2 id=\"a-distributed-approach\"><a class=\"blog-heading-anchor\" href=\"#a-distributed-approach\">A distributed approach</a></h2>\n<p>For correctness, you eventually need some shared state. For speed, you want to avoid synchronous round trips on every request.</p>\n<p>Two common strategies:</p>\n<ol>\n<li><strong>Centralized</strong>: Redis + Lua script (simple, consistent, single dependency)</li>\n<li><strong>Hierarchical</strong>: Local buckets + periodic reconciliation (faster, more complex)</li>\n</ol>\n<h2 id=\"redis--lua-baseline\"><a class=\"blog-heading-anchor\" href=\"#redis--lua-baseline\">Redis + Lua (baseline)</a></h2>\n<p>If you can tolerate a single shared data plane, Redis is a great baseline. Atomically:</p>\n<ol>\n<li>Refill tokens based on elapsed time</li>\n<li>Check tokens</li>\n<li>Decrement on success</li>\n</ol>\n<div class=\"blog-codeblock\" data-lang=\"lua\"><button type=\"button\" class=\"blog-codeblock__copy\" data-blog-copy=\"code\" aria-label=\"Copy code to clipboard\">Copy</button><div class=\"blog-codeblock__inner\"><pre class=\"shiki github-light\" style=\"background-color:#fff;color:#24292e\" tabindex=\"0\" class=\"blog-code-pre blog-code-pre--light\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- pseudocode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- refill, then consume if possible</span></span></code></pre><pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" class=\"blog-code-pre blog-code-pre--dark\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- pseudocode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- refill, then consume if possible</span></span></code></pre></div></div>\n<h2 id=\"where-it-gets-interesting\"><a class=\"blog-heading-anchor\" href=\"#where-it-gets-interesting\">Where it gets interesting</a></h2>\n<p>The difficult part isn’t the algorithm — it’s defining:</p>\n<ul>\n<li>what “fair” means across keys</li>\n<li>what “consistent” means across regions</li>\n<li>what failure modes you accept</li>\n</ul>",
  "toc": [
    {
      "id": "the-problem",
      "depth": 2,
      "text": "The problem"
    },
    {
      "id": "a-practical-model",
      "depth": 2,
      "text": "A practical model"
    },
    {
      "id": "a-distributed-approach",
      "depth": 2,
      "text": "A distributed approach"
    },
    {
      "id": "redis--lua-baseline",
      "depth": 2,
      "text": "Redis + Lua (baseline)"
    },
    {
      "id": "where-it-gets-interesting",
      "depth": 2,
      "text": "Where it gets interesting"
    }
  ]
}
